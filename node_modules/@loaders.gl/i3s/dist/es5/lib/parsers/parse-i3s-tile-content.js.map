{"version":3,"sources":["../../../../src/lib/parsers/parse-i3s-tile-content.ts"],"names":["scratchVector","Vector3","FORMAT_LOADER_MAP","jpeg","ImageLoader","png","CompressedTextureLoader","dds","I3S_ATTRIBUTE_TYPE","parseI3STileContent","arrayBuffer","tile","tileset","options","context","content","featureIds","featureData","constructFeatureDataStruct","attributes","textureUrl","url","i3s","token","loader","textureFormat","fetch","response","image","type","parse","texture","compressed","mipmaps","width","height","data","material","makePbrMaterial","materialDefinition","parseI3SNodeGeometry","byteOffset","featureCount","isDracoGeometry","DracoLoader","draco","attributeNameEntry","decompressedGeometry","vertexCount","header","indices","value","POSITION","NORMAL","COLOR_0","TEXCOORD_0","featureIndex","uvRegion","position","normal","color","uv0","id","updateAttributesMetadata","getFeatureIdsFromFeatureIndexMetadata","flattenFeatureIdsByFeatureIndices","vertexAttributes","attributesOrder","featureAttributes","featureAttributeOrder","headers","parseHeaders","normalizeAttributes","normalizedVertexAttributes","offset","normalizedFeatureAttributes","flattenFeatureIdsByFaceRanges","concatAttributes","parsePositions","enuMatrix","cartographicOrigin","cartesianOrigin","matrix","Matrix4","multiplyRight","positions","normals","colors","normalizeAttribute","texCoords","uvRegions","attributeIndex","cartographicCenter","modelMatrix","invert","byteLength","key","loaderData","dracoAttribute","name","metadata","attribute","normalized","defaultGeometrySchema","store","geometryAttribute","I3S_NAMED_GEOMETRY_ATTRIBUTES","namedAttribute","I3S_NAMED_VERTEX_ATTRIBUTES","count","valueType","valuesPerElement","ordering","buffer","I3S_NAMED_HEADER_ATTRIBUTES","property","TypedArrayTypeHeader","TYPE_ARRAY_MAP","SIZEOF","slice","parseUint64Values","TypedArrayType","GL_TYPE_MAP","size","elementsCount","attributeSize","values","dataView","DataView","index","left","getUint32","right","push","mbs","Ellipsoid","WGS84","cartographicToCartesian","eastNorthUpToFixedFrame","offsetsToCartesians","fixedFrameToENUMatrix","vertices","Float64Array","length","scaleX","double","scaleY","i","x","y","z","subarray","pbrMaterial","pbrMetallicRoughness","baseColorFactor","baseColorTexture","texCoord","alphaCutoff","alphaMode","toUpperCase","emissiveFactor","convertColorFormat","setMaterialTexture","colorFactor","normalizedColor","source","emissiveTexture","metallicRoughnessTexture","normalTexture","occlusionTexture","faceRange","range","featureIdsLength","orderedFeatureIndices","Uint32Array","startIndex","fillId","Number","endValue","prevValue","trianglesCount","endIndex","fill","featureIndices","result","Float32Array","intArray"],"mappings":"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","sourcesContent":["import type {TypedArray} from '@loaders.gl/schema';\nimport {load, parse} from '@loaders.gl/core';\nimport {Vector3, Matrix4} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\n\nimport type {LoaderOptions, LoaderContext} from '@loaders.gl/loader-utils';\nimport {ImageLoader} from '@loaders.gl/images';\nimport {DracoLoader} from '@loaders.gl/draco';\nimport {CompressedTextureLoader} from '@loaders.gl/textures';\n\nimport {Tileset, Tile} from '../../types';\nimport {getUrlWithToken} from '../utils/url-utils';\n\nimport {\n  GL_TYPE_MAP,\n  TYPE_ARRAY_MAP,\n  SIZEOF,\n  I3S_NAMED_HEADER_ATTRIBUTES,\n  I3S_NAMED_VERTEX_ATTRIBUTES,\n  I3S_NAMED_GEOMETRY_ATTRIBUTES\n} from './constants';\n\nconst scratchVector = new Vector3([0, 0, 0]);\n\nconst FORMAT_LOADER_MAP = {\n  jpeg: ImageLoader,\n  png: ImageLoader,\n  'ktx-etc2': CompressedTextureLoader,\n  dds: CompressedTextureLoader\n};\n\nconst I3S_ATTRIBUTE_TYPE = 'i3s-attribute-type';\n\nexport async function parseI3STileContent(\n  arrayBuffer: ArrayBuffer,\n  tile: Tile,\n  tileset: Tileset,\n  options?: LoaderOptions,\n  context?: LoaderContext\n) {\n  tile.content = tile.content || {};\n  tile.content.featureIds = tile.content.featureIds || null;\n\n  // construct featureData from defaultGeometrySchema;\n  tile.content.featureData = constructFeatureDataStruct(tile, tileset);\n  tile.content.attributes = {};\n\n  if (tile.textureUrl) {\n    const url = getUrlWithToken(tile.textureUrl, options?.i3s?.token);\n    const loader = FORMAT_LOADER_MAP[tile.textureFormat] || ImageLoader;\n    // @ts-ignore context must be defined\n    const response = await fetch(url);\n    const arrayBuffer = await response.arrayBuffer();\n\n    if (loader === ImageLoader) {\n      const options = {image: {type: 'data'}};\n      // @ts-ignore context must be defined\n      // Image constructor is not supported in worker thread.\n      // Do parsing image data on the main thread by using context to avoid worker issues.\n      tile.content.texture = await context.parse(arrayBuffer, options);\n    } else if (loader === CompressedTextureLoader) {\n      // @ts-ignore context must be defined\n      const texture = await load(arrayBuffer, CompressedTextureLoader);\n      tile.content.texture = {\n        compressed: true,\n        mipmaps: false,\n        width: texture[0].width,\n        height: texture[0].height,\n        data: texture\n      };\n    }\n  }\n\n  tile.content.material = makePbrMaterial(tile.materialDefinition, tile.content.texture);\n  if (tile.content.material) {\n    tile.content.texture = null;\n  }\n\n  return await parseI3SNodeGeometry(arrayBuffer, tile, context);\n}\n\n/* eslint-disable max-statements */\nasync function parseI3SNodeGeometry(\n  arrayBuffer: ArrayBuffer,\n  tile: Tile = {},\n  context?: LoaderContext\n) {\n  if (!tile.content) {\n    return tile;\n  }\n\n  const content = tile.content;\n  let attributes;\n  let vertexCount;\n  let byteOffset = 0;\n  let featureCount = 0;\n\n  if (tile.isDracoGeometry) {\n    const decompressedGeometry = await parse(arrayBuffer, DracoLoader, {\n      draco: {\n        attributeNameEntry: I3S_ATTRIBUTE_TYPE\n      }\n    });\n\n    vertexCount = decompressedGeometry.header.vertexCount;\n    const indices = decompressedGeometry.indices.value;\n    const {\n      POSITION,\n      NORMAL,\n      COLOR_0,\n      TEXCOORD_0,\n      ['feature-index']: featureIndex,\n      ['uv-region']: uvRegion\n    } = decompressedGeometry.attributes;\n\n    attributes = {\n      position: POSITION,\n      normal: NORMAL,\n      color: COLOR_0,\n      uv0: TEXCOORD_0,\n      uvRegion,\n      id: featureIndex,\n      indices\n    };\n\n    updateAttributesMetadata(attributes, decompressedGeometry);\n\n    const featureIds = getFeatureIdsFromFeatureIndexMetadata(featureIndex);\n\n    if (featureIds) {\n      flattenFeatureIdsByFeatureIndices(attributes, featureIds);\n    }\n  } else {\n    const {vertexAttributes, attributesOrder, featureAttributes, featureAttributeOrder} =\n      content.featureData;\n    // First 8 bytes reserved for header (vertexCount and featureCount)\n    const headers = parseHeaders(content, arrayBuffer);\n    byteOffset = headers.byteOffset;\n    vertexCount = headers.vertexCount;\n    featureCount = headers.featureCount;\n    // Getting vertex attributes such as positions, normals, colors, etc...\n    const {attributes: normalizedVertexAttributes, byteOffset: offset} = normalizeAttributes(\n      arrayBuffer,\n      byteOffset,\n      vertexAttributes,\n      vertexCount,\n      attributesOrder\n    );\n\n    // Getting feature attributes such as featureIds and faceRange\n    const {attributes: normalizedFeatureAttributes} = normalizeAttributes(\n      arrayBuffer,\n      offset,\n      featureAttributes,\n      featureCount,\n      featureAttributeOrder\n    );\n\n    flattenFeatureIdsByFaceRanges(normalizedFeatureAttributes);\n    attributes = concatAttributes(normalizedVertexAttributes, normalizedFeatureAttributes);\n  }\n\n  const {enuMatrix, cartographicOrigin, cartesianOrigin} = parsePositions(\n    attributes.position,\n    tile\n  );\n\n  const matrix = new Matrix4().multiplyRight(enuMatrix);\n\n  content.attributes = {\n    positions: attributes.position,\n    normals: attributes.normal,\n    colors: normalizeAttribute(attributes.color), // Normalize from UInt8\n    texCoords: attributes.uv0,\n    uvRegions: normalizeAttribute(attributes.uvRegion) // Normalize from UInt16\n  };\n  content.indices = attributes.indices || null;\n\n  if (attributes.id && attributes.id.value) {\n    tile.content.featureIds = attributes.id.value;\n  }\n\n  // Remove undefined attributes\n  for (const attributeIndex in content.attributes) {\n    if (!content.attributes[attributeIndex]) {\n      delete content.attributes[attributeIndex];\n    }\n  }\n\n  content.vertexCount = vertexCount;\n  content.cartographicCenter = cartographicOrigin;\n  content.cartesianOrigin = cartesianOrigin;\n  content.modelMatrix = matrix.invert();\n  content.byteLength = arrayBuffer.byteLength;\n\n  return tile;\n}\n\n/**\n * Update attributes with metadata from decompressed geometry.\n * @param decompressedGeometry\n * @param attributes\n */\nfunction updateAttributesMetadata(attributes, decompressedGeometry) {\n  for (const key in decompressedGeometry.loaderData.attributes) {\n    const dracoAttribute = decompressedGeometry.loaderData.attributes[key];\n\n    switch (dracoAttribute.name) {\n      case 'POSITION':\n        attributes.position.metadata = dracoAttribute.metadata;\n        break;\n      case 'feature-index':\n        attributes.id.metadata = dracoAttribute.metadata;\n        break;\n      default:\n        break;\n    }\n  }\n}\n\n/**\n * Do concatenation of attribute objects.\n * Done as separate fucntion to avoid ts errors.\n * @param {Object} normalizedVertexAttributes\n * @param {Object} normalizedFeatureAttributes\n * @returns {object} - result of attributes concatenation.\n */\nfunction concatAttributes(normalizedVertexAttributes, normalizedFeatureAttributes) {\n  return {...normalizedVertexAttributes, ...normalizedFeatureAttributes};\n}\n\n/**\n * Normalize attribute to range [0..1] . Eg. convert colors buffer from [255,255,255,255] to [1,1,1,1]\n * @param {Object} attribute - geometry attribute\n * @returns {Object} - geometry attribute in right format\n */\nfunction normalizeAttribute(attribute) {\n  if (!attribute) {\n    return attribute;\n  }\n  attribute.normalized = true;\n  return attribute;\n}\n\nfunction constructFeatureDataStruct(tile, tileset) {\n  // seed featureData from defaultGeometrySchema\n  const defaultGeometrySchema = tileset.store.defaultGeometrySchema;\n  const featureData = defaultGeometrySchema;\n  // populate the vertex attributes value types and values per element\n  for (const geometryAttribute in I3S_NAMED_GEOMETRY_ATTRIBUTES) {\n    for (const namedAttribute in I3S_NAMED_VERTEX_ATTRIBUTES) {\n      const attribute = defaultGeometrySchema[geometryAttribute][namedAttribute];\n      if (attribute) {\n        const {byteOffset = 0, count = 0, valueType, valuesPerElement} = attribute;\n\n        featureData[geometryAttribute][namedAttribute] = {\n          valueType,\n          valuesPerElement,\n          byteOffset,\n          count\n        };\n      }\n    }\n  }\n\n  featureData.attributesOrder = defaultGeometrySchema.ordering;\n  return featureData;\n}\n\nfunction parseHeaders(content, buffer) {\n  let byteOffset = 0;\n  // First 8 bytes reserved for header (vertexCount and featurecount)\n  let vertexCount = 0;\n  let featureCount = 0;\n  const headers = content.featureData[I3S_NAMED_HEADER_ATTRIBUTES.header];\n  for (const header in headers) {\n    const {property, type} = headers[header];\n    const TypedArrayTypeHeader = TYPE_ARRAY_MAP[type];\n    if (property === I3S_NAMED_HEADER_ATTRIBUTES.vertexCount) {\n      vertexCount = new TypedArrayTypeHeader(buffer, 0, 4)[0];\n      byteOffset += SIZEOF[type];\n    }\n    if (property === I3S_NAMED_HEADER_ATTRIBUTES.featureCount) {\n      featureCount = new TypedArrayTypeHeader(buffer, 4, 4)[0];\n      byteOffset += SIZEOF[type];\n    }\n  }\n  return {\n    vertexCount,\n    featureCount,\n    byteOffset\n  };\n}\n\n/* eslint-enable max-statements */\n\nfunction normalizeAttributes(\n  arrayBuffer,\n  byteOffset,\n  vertexAttributes,\n  vertexCount,\n  attributesOrder\n) {\n  const attributes = {};\n\n  // the order of attributes depend on the order being added to the vertexAttributes object\n  for (const attribute of attributesOrder) {\n    if (vertexAttributes[attribute]) {\n      const {valueType, valuesPerElement} = vertexAttributes[attribute];\n      // update count and byteOffset count by calculating from defaultGeometrySchema + binnary content\n      const count = vertexCount;\n      // protect from arrayBuffer read overunns by NOT assuming node has regions always even though its declared in defaultGeometrySchema.\n      // In i3s 1.6: client is required to decide that based on ./shared resource of the node (materialDefinitions.[Mat_id].params.vertexRegions == true)\n      // In i3s 1.7 the property has been rolled into the 3d scene layer json/node pages.\n      // Code below does not account when the bytelength is actually bigger than\n      // the calculated value (b\\c the tile potentially could have mesh segmentation information).\n      // In those cases tiles without regions could fail or have garbage values.\n      if (byteOffset + count * valuesPerElement > arrayBuffer.byteLength) {\n        break;\n      }\n      const buffer = arrayBuffer.slice(byteOffset);\n      let value: number[] | TypedArray = [];\n\n      if (valueType === 'UInt64') {\n        value = parseUint64Values(buffer, count * valuesPerElement, SIZEOF[valueType]);\n      } else {\n        const TypedArrayType = TYPE_ARRAY_MAP[valueType];\n        value = new TypedArrayType(buffer, 0, count * valuesPerElement);\n      }\n\n      attributes[attribute] = {\n        value,\n        type: GL_TYPE_MAP[valueType],\n        size: valuesPerElement\n      };\n\n      switch (attribute) {\n        case 'color':\n          // @ts-ignore\n          attributes.color.normalized = true;\n          break;\n        case 'position':\n        case 'region':\n        case 'normal':\n        default:\n      }\n\n      byteOffset = byteOffset + count * valuesPerElement * SIZEOF[valueType];\n    }\n  }\n\n  return {attributes, byteOffset};\n}\n\n/**\n * Parse buffer to return array of uint64 values\n *\n * @param buffer\n * @param elementsCount\n * @returns 64-bit array of values until precision is lost after Number.MAX_SAFE_INTEGER\n */\nfunction parseUint64Values(\n  buffer: ArrayBuffer,\n  elementsCount: number,\n  attributeSize: number\n): number[] {\n  const values: number[] = [];\n  const dataView = new DataView(buffer);\n  let offset = 0;\n\n  for (let index = 0; index < elementsCount; index++) {\n    // split 64-bit number into two 32-bit parts\n    const left = dataView.getUint32(offset, true);\n    const right = dataView.getUint32(offset + 4, true);\n    // combine the two 32-bit values\n    const value = left + 2 ** 32 * right;\n\n    values.push(value);\n    offset += attributeSize;\n  }\n\n  return values;\n}\n\nfunction parsePositions(attribute, tile) {\n  const mbs = tile.mbs;\n  const value = attribute.value;\n  const metadata = attribute.metadata;\n  const enuMatrix = new Matrix4();\n  const cartographicOrigin = new Vector3(mbs[0], mbs[1], mbs[2]);\n  const cartesianOrigin = new Vector3();\n  Ellipsoid.WGS84.cartographicToCartesian(cartographicOrigin, cartesianOrigin);\n  Ellipsoid.WGS84.eastNorthUpToFixedFrame(cartesianOrigin, enuMatrix);\n  attribute.value = offsetsToCartesians(value, metadata, cartographicOrigin);\n\n  return {\n    enuMatrix,\n    fixedFrameToENUMatrix: enuMatrix.invert(),\n    cartographicOrigin,\n    cartesianOrigin\n  };\n}\n\n/**\n * Converts position coordinates to absolute cartesian coordinates\n * @param {Float32Array} vertices - \"position\" attribute data\n * @param {Object} metadata - When the geometry is DRACO compressed, contain position attribute's metadata\n *  https://github.com/Esri/i3s-spec/blob/master/docs/1.7/compressedAttributes.cmn.md\n * @param {Vector3} cartographicOrigin - Cartographic origin coordinates\n * @returns {Float64Array} - converted \"position\" data\n */\nfunction offsetsToCartesians(vertices, metadata = {}, cartographicOrigin) {\n  const positions = new Float64Array(vertices.length);\n  const scaleX = (metadata['i3s-scale_x'] && metadata['i3s-scale_x'].double) || 1;\n  const scaleY = (metadata['i3s-scale_y'] && metadata['i3s-scale_y'].double) || 1;\n  for (let i = 0; i < positions.length; i += 3) {\n    positions[i] = vertices[i] * scaleX + cartographicOrigin.x;\n    positions[i + 1] = vertices[i + 1] * scaleY + cartographicOrigin.y;\n    positions[i + 2] = vertices[i + 2] + cartographicOrigin.z;\n  }\n\n  for (let i = 0; i < positions.length; i += 3) {\n    // @ts-ignore\n    Ellipsoid.WGS84.cartographicToCartesian(positions.subarray(i, i + 3), scratchVector);\n    positions[i] = scratchVector.x;\n    positions[i + 1] = scratchVector.y;\n    positions[i + 2] = scratchVector.z;\n  }\n\n  return positions;\n}\n\n/**\n * Makes a glTF-compatible PBR material from an I3S material definition\n * @param {object} materialDefinition - i3s material definition\n *  https://github.com/Esri/i3s-spec/blob/master/docs/1.7/materialDefinitions.cmn.md\n * @param {object} texture - texture image\n * @returns {object}\n */\nfunction makePbrMaterial(materialDefinition, texture) {\n  let pbrMaterial;\n  if (materialDefinition) {\n    pbrMaterial = {\n      ...materialDefinition,\n      pbrMetallicRoughness: materialDefinition.pbrMetallicRoughness\n        ? {...materialDefinition.pbrMetallicRoughness}\n        : {baseColorFactor: [255, 255, 255, 255]}\n    };\n  } else {\n    pbrMaterial = {\n      pbrMetallicRoughness: {}\n    };\n    if (texture) {\n      pbrMaterial.pbrMetallicRoughness.baseColorTexture = {texCoord: 0};\n    } else {\n      pbrMaterial.pbrMetallicRoughness.baseColorFactor = [255, 255, 255, 255];\n    }\n  }\n\n  // Set default 0.25 per spec https://github.com/Esri/i3s-spec/blob/master/docs/1.7/materialDefinitions.cmn.md\n  pbrMaterial.alphaCutoff = pbrMaterial.alphaCutoff || 0.25;\n\n  if (pbrMaterial.alphaMode) {\n    // I3S contain alphaMode in lowerCase\n    pbrMaterial.alphaMode = pbrMaterial.alphaMode.toUpperCase();\n  }\n\n  // Convert colors from [255,255,255,255] to [1,1,1,1]\n  if (pbrMaterial.emissiveFactor) {\n    pbrMaterial.emissiveFactor = convertColorFormat(pbrMaterial.emissiveFactor);\n  }\n  if (pbrMaterial.pbrMetallicRoughness && pbrMaterial.pbrMetallicRoughness.baseColorFactor) {\n    pbrMaterial.pbrMetallicRoughness.baseColorFactor = convertColorFormat(\n      pbrMaterial.pbrMetallicRoughness.baseColorFactor\n    );\n  }\n\n  setMaterialTexture(pbrMaterial, texture);\n\n  return pbrMaterial;\n}\n\n/**\n * Convert color from [255,255,255,255] to [1,1,1,1]\n * @param {Array} colorFactor - color array\n * @returns {Array} - new color array\n */\nfunction convertColorFormat(colorFactor) {\n  const normalizedColor = [...colorFactor];\n  for (let index = 0; index < colorFactor.length; index++) {\n    normalizedColor[index] = colorFactor[index] / 255;\n  }\n  return normalizedColor;\n}\n\n/**\n * Set texture in PBR material\n * @param {object} material - i3s material definition\n * @param {object} image - texture image\n * @returns {void}\n */\nfunction setMaterialTexture(material, image) {\n  const texture = {source: {image}};\n  // I3SLoader now support loading only one texture. This elseif sequence will assign this texture to one of\n  // properties defined in materialDefinition\n  if (material.pbrMetallicRoughness && material.pbrMetallicRoughness.baseColorTexture) {\n    material.pbrMetallicRoughness.baseColorTexture = {\n      ...material.pbrMetallicRoughness.baseColorTexture,\n      texture\n    };\n  } else if (material.emissiveTexture) {\n    material.emissiveTexture = {...material.emissiveTexture, texture};\n  } else if (\n    material.pbrMetallicRoughness &&\n    material.pbrMetallicRoughness.metallicRoughnessTexture\n  ) {\n    material.pbrMetallicRoughness.metallicRoughnessTexture = {\n      ...material.pbrMetallicRoughness.metallicRoughnessTexture,\n      texture\n    };\n  } else if (material.normalTexture) {\n    material.normalTexture = {...material.normalTexture, texture};\n  } else if (material.occlusionTexture) {\n    material.occlusionTexture = {...material.occlusionTexture, texture};\n  }\n}\n\n/**\n * Flatten feature ids using face ranges\n * @param {object} normalizedFeatureAttributes\n * @returns {void}\n */\nfunction flattenFeatureIdsByFaceRanges(normalizedFeatureAttributes) {\n  const {id, faceRange} = normalizedFeatureAttributes;\n\n  if (!id || !faceRange) {\n    return;\n  }\n\n  const featureIds = id.value;\n  const range = faceRange.value;\n  const featureIdsLength = range[range.length - 1] + 1;\n  const orderedFeatureIndices = new Uint32Array(featureIdsLength * 3);\n\n  let featureIndex = 0;\n  let startIndex = 0;\n\n  for (let index = 1; index < range.length; index += 2) {\n    const fillId = Number(featureIds[featureIndex]);\n    const endValue = range[index];\n    const prevValue = range[index - 1];\n    const trianglesCount = endValue - prevValue + 1;\n    const endIndex = startIndex + trianglesCount * 3;\n\n    orderedFeatureIndices.fill(fillId, startIndex, endIndex);\n\n    featureIndex++;\n    startIndex = endIndex;\n  }\n\n  normalizedFeatureAttributes.id.value = orderedFeatureIndices;\n}\n\n/**\n * Flatten feature ids using featureIndices\n * @param {object} attributes\n * @param {any} featureIds\n * @returns {void}\n */\nfunction flattenFeatureIdsByFeatureIndices(attributes, featureIds) {\n  const featureIndices = attributes.id.value;\n  const result = new Float32Array(featureIndices.length);\n\n  for (let index = 0; index < featureIndices.length; index++) {\n    result[index] = featureIds[featureIndices[index]];\n  }\n\n  attributes.id.value = result;\n}\n\n/**\n * Flatten feature ids using featureIndices\n * @param {object} featureIndex\n * @returns {Int32Array}\n */\nfunction getFeatureIdsFromFeatureIndexMetadata(featureIndex) {\n  return (\n    featureIndex &&\n    featureIndex.metadata &&\n    featureIndex.metadata['i3s-feature-ids'] &&\n    featureIndex.metadata['i3s-feature-ids'].intArray\n  );\n}\n"],"file":"parse-i3s-tile-content.js"}