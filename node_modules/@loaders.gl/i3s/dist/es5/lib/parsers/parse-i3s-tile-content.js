"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseI3STileContent = parseI3STileContent;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _core = require("@loaders.gl/core");

var _core2 = require("@math.gl/core");

var _geospatial = require("@math.gl/geospatial");

var _images = require("@loaders.gl/images");

var _draco = require("@loaders.gl/draco");

var _textures = require("@loaders.gl/textures");

var _urlUtils = require("../utils/url-utils");

var _constants = require("./constants");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var scratchVector = new _core2.Vector3([0, 0, 0]);
var FORMAT_LOADER_MAP = {
  jpeg: _images.ImageLoader,
  png: _images.ImageLoader,
  'ktx-etc2': _textures.CompressedTextureLoader,
  dds: _textures.CompressedTextureLoader
};
var I3S_ATTRIBUTE_TYPE = 'i3s-attribute-type';

function parseI3STileContent(_x, _x2, _x3, _x4, _x5) {
  return _parseI3STileContent.apply(this, arguments);
}

function _parseI3STileContent() {
  _parseI3STileContent = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(arrayBuffer, tile, tileset, options, context) {
    var _options$i3s, url, loader, response, _arrayBuffer, _options, texture;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            tile.content = tile.content || {};
            tile.content.featureIds = tile.content.featureIds || null;
            tile.content.featureData = constructFeatureDataStruct(tile, tileset);
            tile.content.attributes = {};

            if (!tile.textureUrl) {
              _context.next = 25;
              break;
            }

            url = (0, _urlUtils.getUrlWithToken)(tile.textureUrl, options === null || options === void 0 ? void 0 : (_options$i3s = options.i3s) === null || _options$i3s === void 0 ? void 0 : _options$i3s.token);
            loader = FORMAT_LOADER_MAP[tile.textureFormat] || _images.ImageLoader;
            _context.next = 9;
            return fetch(url);

          case 9:
            response = _context.sent;
            _context.next = 12;
            return response.arrayBuffer();

          case 12:
            _arrayBuffer = _context.sent;

            if (!(loader === _images.ImageLoader)) {
              _context.next = 20;
              break;
            }

            _options = {
              image: {
                type: 'data'
              }
            };
            _context.next = 17;
            return context.parse(_arrayBuffer, _options);

          case 17:
            tile.content.texture = _context.sent;
            _context.next = 25;
            break;

          case 20:
            if (!(loader === _textures.CompressedTextureLoader)) {
              _context.next = 25;
              break;
            }

            _context.next = 23;
            return (0, _core.load)(_arrayBuffer, _textures.CompressedTextureLoader);

          case 23:
            texture = _context.sent;
            tile.content.texture = {
              compressed: true,
              mipmaps: false,
              width: texture[0].width,
              height: texture[0].height,
              data: texture
            };

          case 25:
            tile.content.material = makePbrMaterial(tile.materialDefinition, tile.content.texture);

            if (tile.content.material) {
              tile.content.texture = null;
            }

            _context.next = 29;
            return parseI3SNodeGeometry(arrayBuffer, tile, context);

          case 29:
            return _context.abrupt("return", _context.sent);

          case 30:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parseI3STileContent.apply(this, arguments);
}

function parseI3SNodeGeometry(_x6) {
  return _parseI3SNodeGeometry.apply(this, arguments);
}

function _parseI3SNodeGeometry() {
  _parseI3SNodeGeometry = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(arrayBuffer) {
    var tile,
        context,
        content,
        attributes,
        vertexCount,
        byteOffset,
        featureCount,
        decompressedGeometry,
        indices,
        _decompressedGeometry,
        POSITION,
        NORMAL,
        COLOR_0,
        TEXCOORD_0,
        featureIndex,
        uvRegion,
        featureIds,
        _content$featureData,
        vertexAttributes,
        attributesOrder,
        featureAttributes,
        featureAttributeOrder,
        headers,
        _normalizeAttributes,
        normalizedVertexAttributes,
        offset,
        _normalizeAttributes2,
        normalizedFeatureAttributes,
        _parsePositions,
        enuMatrix,
        cartographicOrigin,
        cartesianOrigin,
        matrix,
        attributeIndex,
        _args2 = arguments;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            tile = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
            context = _args2.length > 2 ? _args2[2] : undefined;

            if (tile.content) {
              _context2.next = 4;
              break;
            }

            return _context2.abrupt("return", tile);

          case 4:
            content = tile.content;
            byteOffset = 0;
            featureCount = 0;

            if (!tile.isDracoGeometry) {
              _context2.next = 20;
              break;
            }

            _context2.next = 10;
            return (0, _core.parse)(arrayBuffer, _draco.DracoLoader, {
              draco: {
                attributeNameEntry: I3S_ATTRIBUTE_TYPE
              }
            });

          case 10:
            decompressedGeometry = _context2.sent;
            vertexCount = decompressedGeometry.header.vertexCount;
            indices = decompressedGeometry.indices.value;
            _decompressedGeometry = decompressedGeometry.attributes, POSITION = _decompressedGeometry.POSITION, NORMAL = _decompressedGeometry.NORMAL, COLOR_0 = _decompressedGeometry.COLOR_0, TEXCOORD_0 = _decompressedGeometry.TEXCOORD_0, featureIndex = _decompressedGeometry['feature-index'], uvRegion = _decompressedGeometry['uv-region'];
            attributes = {
              position: POSITION,
              normal: NORMAL,
              color: COLOR_0,
              uv0: TEXCOORD_0,
              uvRegion: uvRegion,
              id: featureIndex,
              indices: indices
            };
            updateAttributesMetadata(attributes, decompressedGeometry);
            featureIds = getFeatureIdsFromFeatureIndexMetadata(featureIndex);

            if (featureIds) {
              flattenFeatureIdsByFeatureIndices(attributes, featureIds);
            }

            _context2.next = 29;
            break;

          case 20:
            _content$featureData = content.featureData, vertexAttributes = _content$featureData.vertexAttributes, attributesOrder = _content$featureData.attributesOrder, featureAttributes = _content$featureData.featureAttributes, featureAttributeOrder = _content$featureData.featureAttributeOrder;
            headers = parseHeaders(content, arrayBuffer);
            byteOffset = headers.byteOffset;
            vertexCount = headers.vertexCount;
            featureCount = headers.featureCount;
            _normalizeAttributes = normalizeAttributes(arrayBuffer, byteOffset, vertexAttributes, vertexCount, attributesOrder), normalizedVertexAttributes = _normalizeAttributes.attributes, offset = _normalizeAttributes.byteOffset;
            _normalizeAttributes2 = normalizeAttributes(arrayBuffer, offset, featureAttributes, featureCount, featureAttributeOrder), normalizedFeatureAttributes = _normalizeAttributes2.attributes;
            flattenFeatureIdsByFaceRanges(normalizedFeatureAttributes);
            attributes = concatAttributes(normalizedVertexAttributes, normalizedFeatureAttributes);

          case 29:
            _parsePositions = parsePositions(attributes.position, tile), enuMatrix = _parsePositions.enuMatrix, cartographicOrigin = _parsePositions.cartographicOrigin, cartesianOrigin = _parsePositions.cartesianOrigin;
            matrix = new _core2.Matrix4().multiplyRight(enuMatrix);
            content.attributes = {
              positions: attributes.position,
              normals: attributes.normal,
              colors: normalizeAttribute(attributes.color),
              texCoords: attributes.uv0,
              uvRegions: normalizeAttribute(attributes.uvRegion)
            };
            content.indices = attributes.indices || null;

            if (attributes.id && attributes.id.value) {
              tile.content.featureIds = attributes.id.value;
            }

            for (attributeIndex in content.attributes) {
              if (!content.attributes[attributeIndex]) {
                delete content.attributes[attributeIndex];
              }
            }

            content.vertexCount = vertexCount;
            content.cartographicCenter = cartographicOrigin;
            content.cartesianOrigin = cartesianOrigin;
            content.modelMatrix = matrix.invert();
            content.byteLength = arrayBuffer.byteLength;
            return _context2.abrupt("return", tile);

          case 41:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _parseI3SNodeGeometry.apply(this, arguments);
}

function updateAttributesMetadata(attributes, decompressedGeometry) {
  for (var key in decompressedGeometry.loaderData.attributes) {
    var dracoAttribute = decompressedGeometry.loaderData.attributes[key];

    switch (dracoAttribute.name) {
      case 'POSITION':
        attributes.position.metadata = dracoAttribute.metadata;
        break;

      case 'feature-index':
        attributes.id.metadata = dracoAttribute.metadata;
        break;

      default:
        break;
    }
  }
}

function concatAttributes(normalizedVertexAttributes, normalizedFeatureAttributes) {
  return _objectSpread(_objectSpread({}, normalizedVertexAttributes), normalizedFeatureAttributes);
}

function normalizeAttribute(attribute) {
  if (!attribute) {
    return attribute;
  }

  attribute.normalized = true;
  return attribute;
}

function constructFeatureDataStruct(tile, tileset) {
  var defaultGeometrySchema = tileset.store.defaultGeometrySchema;
  var featureData = defaultGeometrySchema;

  for (var geometryAttribute in _constants.I3S_NAMED_GEOMETRY_ATTRIBUTES) {
    for (var namedAttribute in _constants.I3S_NAMED_VERTEX_ATTRIBUTES) {
      var attribute = defaultGeometrySchema[geometryAttribute][namedAttribute];

      if (attribute) {
        var _attribute$byteOffset = attribute.byteOffset,
            byteOffset = _attribute$byteOffset === void 0 ? 0 : _attribute$byteOffset,
            _attribute$count = attribute.count,
            count = _attribute$count === void 0 ? 0 : _attribute$count,
            valueType = attribute.valueType,
            valuesPerElement = attribute.valuesPerElement;
        featureData[geometryAttribute][namedAttribute] = {
          valueType: valueType,
          valuesPerElement: valuesPerElement,
          byteOffset: byteOffset,
          count: count
        };
      }
    }
  }

  featureData.attributesOrder = defaultGeometrySchema.ordering;
  return featureData;
}

function parseHeaders(content, buffer) {
  var byteOffset = 0;
  var vertexCount = 0;
  var featureCount = 0;
  var headers = content.featureData[_constants.I3S_NAMED_HEADER_ATTRIBUTES.header];

  for (var header in headers) {
    var _headers$header = headers[header],
        property = _headers$header.property,
        type = _headers$header.type;
    var TypedArrayTypeHeader = _constants.TYPE_ARRAY_MAP[type];

    if (property === _constants.I3S_NAMED_HEADER_ATTRIBUTES.vertexCount) {
      vertexCount = new TypedArrayTypeHeader(buffer, 0, 4)[0];
      byteOffset += _constants.SIZEOF[type];
    }

    if (property === _constants.I3S_NAMED_HEADER_ATTRIBUTES.featureCount) {
      featureCount = new TypedArrayTypeHeader(buffer, 4, 4)[0];
      byteOffset += _constants.SIZEOF[type];
    }
  }

  return {
    vertexCount: vertexCount,
    featureCount: featureCount,
    byteOffset: byteOffset
  };
}

function normalizeAttributes(arrayBuffer, byteOffset, vertexAttributes, vertexCount, attributesOrder) {
  var attributes = {};

  var _iterator = _createForOfIteratorHelper(attributesOrder),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var attribute = _step.value;

      if (vertexAttributes[attribute]) {
        var _vertexAttributes$att = vertexAttributes[attribute],
            valueType = _vertexAttributes$att.valueType,
            valuesPerElement = _vertexAttributes$att.valuesPerElement;
        var count = vertexCount;

        if (byteOffset + count * valuesPerElement > arrayBuffer.byteLength) {
          break;
        }

        var buffer = arrayBuffer.slice(byteOffset);
        var value = [];

        if (valueType === 'UInt64') {
          value = parseUint64Values(buffer, count * valuesPerElement, _constants.SIZEOF[valueType]);
        } else {
          var TypedArrayType = _constants.TYPE_ARRAY_MAP[valueType];
          value = new TypedArrayType(buffer, 0, count * valuesPerElement);
        }

        attributes[attribute] = {
          value: value,
          type: _constants.GL_TYPE_MAP[valueType],
          size: valuesPerElement
        };

        switch (attribute) {
          case 'color':
            attributes.color.normalized = true;
            break;

          case 'position':
          case 'region':
          case 'normal':
          default:
        }

        byteOffset = byteOffset + count * valuesPerElement * _constants.SIZEOF[valueType];
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return {
    attributes: attributes,
    byteOffset: byteOffset
  };
}

function parseUint64Values(buffer, elementsCount, attributeSize) {
  var values = [];
  var dataView = new DataView(buffer);
  var offset = 0;

  for (var index = 0; index < elementsCount; index++) {
    var left = dataView.getUint32(offset, true);
    var right = dataView.getUint32(offset + 4, true);
    var value = left + Math.pow(2, 32) * right;
    values.push(value);
    offset += attributeSize;
  }

  return values;
}

function parsePositions(attribute, tile) {
  var mbs = tile.mbs;
  var value = attribute.value;
  var metadata = attribute.metadata;
  var enuMatrix = new _core2.Matrix4();
  var cartographicOrigin = new _core2.Vector3(mbs[0], mbs[1], mbs[2]);
  var cartesianOrigin = new _core2.Vector3();

  _geospatial.Ellipsoid.WGS84.cartographicToCartesian(cartographicOrigin, cartesianOrigin);

  _geospatial.Ellipsoid.WGS84.eastNorthUpToFixedFrame(cartesianOrigin, enuMatrix);

  attribute.value = offsetsToCartesians(value, metadata, cartographicOrigin);
  return {
    enuMatrix: enuMatrix,
    fixedFrameToENUMatrix: enuMatrix.invert(),
    cartographicOrigin: cartographicOrigin,
    cartesianOrigin: cartesianOrigin
  };
}

function offsetsToCartesians(vertices) {
  var metadata = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var cartographicOrigin = arguments.length > 2 ? arguments[2] : undefined;
  var positions = new Float64Array(vertices.length);
  var scaleX = metadata['i3s-scale_x'] && metadata['i3s-scale_x'].double || 1;
  var scaleY = metadata['i3s-scale_y'] && metadata['i3s-scale_y'].double || 1;

  for (var i = 0; i < positions.length; i += 3) {
    positions[i] = vertices[i] * scaleX + cartographicOrigin.x;
    positions[i + 1] = vertices[i + 1] * scaleY + cartographicOrigin.y;
    positions[i + 2] = vertices[i + 2] + cartographicOrigin.z;
  }

  for (var _i = 0; _i < positions.length; _i += 3) {
    _geospatial.Ellipsoid.WGS84.cartographicToCartesian(positions.subarray(_i, _i + 3), scratchVector);

    positions[_i] = scratchVector.x;
    positions[_i + 1] = scratchVector.y;
    positions[_i + 2] = scratchVector.z;
  }

  return positions;
}

function makePbrMaterial(materialDefinition, texture) {
  var pbrMaterial;

  if (materialDefinition) {
    pbrMaterial = _objectSpread(_objectSpread({}, materialDefinition), {}, {
      pbrMetallicRoughness: materialDefinition.pbrMetallicRoughness ? _objectSpread({}, materialDefinition.pbrMetallicRoughness) : {
        baseColorFactor: [255, 255, 255, 255]
      }
    });
  } else {
    pbrMaterial = {
      pbrMetallicRoughness: {}
    };

    if (texture) {
      pbrMaterial.pbrMetallicRoughness.baseColorTexture = {
        texCoord: 0
      };
    } else {
      pbrMaterial.pbrMetallicRoughness.baseColorFactor = [255, 255, 255, 255];
    }
  }

  pbrMaterial.alphaCutoff = pbrMaterial.alphaCutoff || 0.25;

  if (pbrMaterial.alphaMode) {
    pbrMaterial.alphaMode = pbrMaterial.alphaMode.toUpperCase();
  }

  if (pbrMaterial.emissiveFactor) {
    pbrMaterial.emissiveFactor = convertColorFormat(pbrMaterial.emissiveFactor);
  }

  if (pbrMaterial.pbrMetallicRoughness && pbrMaterial.pbrMetallicRoughness.baseColorFactor) {
    pbrMaterial.pbrMetallicRoughness.baseColorFactor = convertColorFormat(pbrMaterial.pbrMetallicRoughness.baseColorFactor);
  }

  setMaterialTexture(pbrMaterial, texture);
  return pbrMaterial;
}

function convertColorFormat(colorFactor) {
  var normalizedColor = (0, _toConsumableArray2.default)(colorFactor);

  for (var index = 0; index < colorFactor.length; index++) {
    normalizedColor[index] = colorFactor[index] / 255;
  }

  return normalizedColor;
}

function setMaterialTexture(material, image) {
  var texture = {
    source: {
      image: image
    }
  };

  if (material.pbrMetallicRoughness && material.pbrMetallicRoughness.baseColorTexture) {
    material.pbrMetallicRoughness.baseColorTexture = _objectSpread(_objectSpread({}, material.pbrMetallicRoughness.baseColorTexture), {}, {
      texture: texture
    });
  } else if (material.emissiveTexture) {
    material.emissiveTexture = _objectSpread(_objectSpread({}, material.emissiveTexture), {}, {
      texture: texture
    });
  } else if (material.pbrMetallicRoughness && material.pbrMetallicRoughness.metallicRoughnessTexture) {
    material.pbrMetallicRoughness.metallicRoughnessTexture = _objectSpread(_objectSpread({}, material.pbrMetallicRoughness.metallicRoughnessTexture), {}, {
      texture: texture
    });
  } else if (material.normalTexture) {
    material.normalTexture = _objectSpread(_objectSpread({}, material.normalTexture), {}, {
      texture: texture
    });
  } else if (material.occlusionTexture) {
    material.occlusionTexture = _objectSpread(_objectSpread({}, material.occlusionTexture), {}, {
      texture: texture
    });
  }
}

function flattenFeatureIdsByFaceRanges(normalizedFeatureAttributes) {
  var id = normalizedFeatureAttributes.id,
      faceRange = normalizedFeatureAttributes.faceRange;

  if (!id || !faceRange) {
    return;
  }

  var featureIds = id.value;
  var range = faceRange.value;
  var featureIdsLength = range[range.length - 1] + 1;
  var orderedFeatureIndices = new Uint32Array(featureIdsLength * 3);
  var featureIndex = 0;
  var startIndex = 0;

  for (var index = 1; index < range.length; index += 2) {
    var fillId = Number(featureIds[featureIndex]);
    var endValue = range[index];
    var prevValue = range[index - 1];
    var trianglesCount = endValue - prevValue + 1;
    var endIndex = startIndex + trianglesCount * 3;
    orderedFeatureIndices.fill(fillId, startIndex, endIndex);
    featureIndex++;
    startIndex = endIndex;
  }

  normalizedFeatureAttributes.id.value = orderedFeatureIndices;
}

function flattenFeatureIdsByFeatureIndices(attributes, featureIds) {
  var featureIndices = attributes.id.value;
  var result = new Float32Array(featureIndices.length);

  for (var index = 0; index < featureIndices.length; index++) {
    result[index] = featureIds[featureIndices[index]];
  }

  attributes.id.value = result;
}

function getFeatureIdsFromFeatureIndexMetadata(featureIndex) {
  return featureIndex && featureIndex.metadata && featureIndex.metadata['i3s-feature-ids'] && featureIndex.metadata['i3s-feature-ids'].intArray;
}
//# sourceMappingURL=parse-i3s-tile-content.js.map