"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeTileData = normalizeTileData;
exports.normalizeTileNonUrlData = normalizeTileNonUrlData;
exports.normalizeTilesetData = normalizeTilesetData;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _culling = require("@math.gl/culling");

var _geospatial = require("@math.gl/geospatial");

var _core = require("@loaders.gl/core");

var _tiles = require("@loaders.gl/tiles");

var _i3sNodepagesTiles = _interopRequireDefault(require("../helpers/i3s-nodepages-tiles"));

var _urlUtils = require("../utils/url-utils");

function normalizeTileData(tile, options, context) {
  tile.url = context.url;

  if (tile.featureData) {
    tile.featureUrl = "".concat(tile.url, "/").concat(tile.featureData[0].href);
  }

  if (tile.geometryData) {
    tile.contentUrl = "".concat(tile.url, "/").concat(tile.geometryData[0].href);
  }

  if (tile.textureData) {
    tile.textureUrl = "".concat(tile.url, "/").concat(tile.textureData[0].href);
  }

  if (tile.attributeData) {
    tile.attributeUrls = (0, _urlUtils.generateTileAttributeUrls)(tile);
  }

  return normalizeTileNonUrlData(tile);
}

function normalizeTileNonUrlData(tile) {
  var box = tile.obb ? [].concat((0, _toConsumableArray2.default)(_geospatial.Ellipsoid.WGS84.cartographicToCartesian(tile.obb.center)), (0, _toConsumableArray2.default)(tile.obb.halfSize), (0, _toConsumableArray2.default)(tile.obb.quaternion)) : undefined;
  var sphere;

  if (tile.mbs) {
    sphere = [].concat((0, _toConsumableArray2.default)(_geospatial.Ellipsoid.WGS84.cartographicToCartesian(tile.mbs.slice(0, 3))), [tile.mbs[3]]);
  } else if (box) {
    var obb = new _culling.OrientedBoundingBox().fromCenterHalfSizeQuaternion(box.slice(0, 3), tile.obb.halfSize, tile.obb.quaternion);
    var boundingSphere = obb.getBoundingSphere();
    sphere = [].concat((0, _toConsumableArray2.default)(boundingSphere.center), [boundingSphere.radius]);
    tile.mbs = [].concat((0, _toConsumableArray2.default)(tile.obb.center), [boundingSphere.radius]);
  }

  tile.boundingVolume = {
    sphere: sphere,
    box: box
  };
  tile.lodMetricType = tile.lodSelection[0].metricType;
  tile.lodMetricValue = tile.lodSelection[0].maxError;
  tile.transformMatrix = tile.transform;
  tile.type = _tiles.TILE_TYPE.MESH;
  tile.refine = _tiles.TILE_REFINEMENT.REPLACE;
  return tile;
}

function normalizeTilesetData(_x, _x2, _x3) {
  return _normalizeTilesetData.apply(this, arguments);
}

function _normalizeTilesetData() {
  _normalizeTilesetData = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(tileset, options, context) {
    var _options$i3s, rootNodeUrl;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            tileset.url = context.url;

            if (!tileset.nodePages) {
              _context.next = 8;
              break;
            }

            tileset.nodePagesTile = new _i3sNodepagesTiles.default(tileset, options);
            _context.next = 5;
            return tileset.nodePagesTile.formTileFromNodePages(0);

          case 5:
            tileset.root = _context.sent;
            _context.next = 12;
            break;

          case 8:
            rootNodeUrl = (0, _urlUtils.getUrlWithToken)("".concat(tileset.url, "/nodes/root"), (_options$i3s = options.i3s) === null || _options$i3s === void 0 ? void 0 : _options$i3s.token);
            _context.next = 11;
            return (0, _core.load)(rootNodeUrl, tileset.loader, {
              i3s: {
                loadContent: false,
                isTileHeader: true,
                isTileset: false
              }
            });

          case 11:
            tileset.root = _context.sent;

          case 12:
            tileset.basePath = tileset.url;
            tileset.type = _tiles.TILESET_TYPE.I3S;
            tileset.lodMetricType = tileset.root.lodMetricType;
            tileset.lodMetricValue = tileset.root.lodMetricValue;

          case 16:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _normalizeTilesetData.apply(this, arguments);
}
//# sourceMappingURL=parse-i3s.js.map