{"version":3,"sources":["../../src/i3s-attribute-loader.ts"],"names":["load","parseI3STileAttribute","getUrlWithToken","VERSION","EMPTY_VALUE","REJECTED_STATUS","I3SAttributeLoader","name","id","module","version","mimeTypes","parse","extensions","options","binary","data","loadFeatureAttributes","tile","featureId","attributeStorageInfo","attributeUrls","getAttributesData","attributes","attributeLoadPromises","index","length","url","i3s","token","attributeName","attributeType","getAttributeValueType","loadOptions","promise","push","Promise","allSettled","error","generateAttributesByFeatureId","tileset","header","attribute","hasOwnProperty","attributeValues","valueType","objectIds","find","value","OBJECTID","attributeIndex","indexOf","getFeatureAttributesByIndex","featureIdIndex","attributesObject","getAttributeByIndexAndAttributeName","formatAttributeValue","attributesName","attributeObject","status","toString","replace","trim"],"mappings":"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","sourcesContent":["import type {LoaderWithParser} from '@loaders.gl/loader-utils';\nimport {load} from '@loaders.gl/core';\nimport {parseI3STileAttribute} from './lib/parsers/parse-i3s-attribute';\nimport {getUrlWithToken} from './lib/utils/url-utils';\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\nconst EMPTY_VALUE = '';\nconst REJECTED_STATUS = 'rejected';\n/**\n * Loader for I3S attributes\n */\nexport const I3SAttributeLoader: LoaderWithParser = {\n  name: 'I3S Attribute',\n  id: 'i3s-attribute',\n  module: 'i3s',\n  version: VERSION,\n  mimeTypes: ['application/binary'],\n  parse,\n  extensions: ['bin'],\n  options: {},\n  binary: true\n};\n\nasync function parse(data, options) {\n  data = parseI3STileAttribute(data, options);\n  return data;\n}\n\n/**\n * Load attributes based on feature id\n * @param {Object} tile\n * @param {number} featureId\n * @param {Object} options\n * @returns {Promise}\n */\n// eslint-disable-next-line complexity\nexport async function loadFeatureAttributes(tile, featureId, options = {}) {\n  const {attributeStorageInfo, attributeUrls} = getAttributesData(tile);\n\n  if (!attributeStorageInfo || !attributeUrls || !featureId) {\n    return null;\n  }\n\n  let attributes: object[] = [];\n  const attributeLoadPromises: Promise<object>[] = [];\n\n  for (let index = 0; index < attributeStorageInfo.length; index++) {\n    // @ts-ignore\n    const url = getUrlWithToken(attributeUrls[index], options.i3s?.token);\n    const attributeName = attributeStorageInfo[index].name;\n    const attributeType = getAttributeValueType(attributeStorageInfo[index]);\n    const loadOptions = {...options, attributeName, attributeType};\n    const promise = load(url, I3SAttributeLoader, loadOptions);\n\n    attributeLoadPromises.push(promise);\n  }\n  try {\n    attributes = await Promise.allSettled(attributeLoadPromises);\n  } catch (error) {\n    // do nothing\n  }\n\n  if (!attributes.length) {\n    return null;\n  }\n\n  return generateAttributesByFeatureId(attributes, attributeStorageInfo, featureId);\n}\n\nfunction getAttributesData(tile) {\n  const attributeStorageInfo =\n    tile && tile.tileset && tile.tileset.tileset && tile.tileset.tileset.attributeStorageInfo;\n  const attributeUrls = tile && tile.header && tile.header.attributeUrls;\n\n  return {attributeStorageInfo, attributeUrls};\n}\n\n/**\n * Get attribute value type based on property names\n * @param {Object} attribute\n * @returns {String}\n */\nfunction getAttributeValueType(attribute) {\n  if (attribute.hasOwnProperty('objectIds')) {\n    return 'Oid32';\n  } else if (attribute.hasOwnProperty('attributeValues')) {\n    return attribute.attributeValues.valueType;\n  }\n  return '';\n}\n\n/**\n * Generates mapping featureId to feature attributes\n * @param {Array} attributes\n * @param {Object} attributeStorageInfo\n * @param {number} featureId\n * @returns {Object}\n */\nfunction generateAttributesByFeatureId(attributes, attributeStorageInfo, featureId) {\n  const objectIds = attributes.find((attribute) => attribute.value.OBJECTID);\n\n  if (!objectIds) {\n    return null;\n  }\n\n  const attributeIndex = objectIds.value.OBJECTID.indexOf(featureId);\n\n  if (attributeIndex < 0) {\n    return null;\n  }\n\n  return getFeatureAttributesByIndex(attributes, attributeIndex, attributeStorageInfo);\n}\n\n/**\n * Generates attribute object for feature mapping by feature id\n * @param {Array} attributes\n * @param {Number} featureIdIndex\n * @param {Object} attributeStorageInfo\n * @returns {Object}\n */\nfunction getFeatureAttributesByIndex(attributes, featureIdIndex, attributeStorageInfo) {\n  const attributesObject = {};\n\n  for (let index = 0; index < attributeStorageInfo.length; index++) {\n    const attributeName = attributeStorageInfo[index].name;\n    const attribute = getAttributeByIndexAndAttributeName(attributes, index, attributeName);\n    attributesObject[attributeName] = formatAttributeValue(attribute, featureIdIndex);\n  }\n\n  return attributesObject;\n}\n\n/**\n * Return attribute value if it presents in atrributes list\n * @param {array} attributes\n * @param {number} index\n * @param {string} attributesName\n */\nfunction getAttributeByIndexAndAttributeName(attributes, index, attributesName) {\n  const attributeObject = attributes[index];\n\n  if (attributeObject.status === REJECTED_STATUS) {\n    return null;\n  }\n\n  return attributeObject.value[attributesName];\n}\n\n/**\n * Do formatting of attribute values or return empty string.\n * @param {Array} attribute\n * @param {Number} featureIdIndex\n * @returns {String}\n */\nfunction formatAttributeValue(attribute, featureIdIndex) {\n  return attribute && attribute[featureIdIndex]\n    ? attribute[featureIdIndex]\n      .toString()\n    // eslint-disable-next-line no-control-regex\n      .replace(/\\u0000/g, '')\n      .trim()\n    : EMPTY_VALUE;\n}\n"],"file":"i3s-attribute-loader.js"}