{"version":3,"sources":["../../../../src/lib/parsers/parse-i3s-tile-content.ts"],"names":["load","parse","Vector3","Matrix4","Ellipsoid","ImageLoader","DracoLoader","CompressedTextureLoader","getUrlWithToken","GL_TYPE_MAP","TYPE_ARRAY_MAP","SIZEOF","I3S_NAMED_HEADER_ATTRIBUTES","I3S_NAMED_VERTEX_ATTRIBUTES","I3S_NAMED_GEOMETRY_ATTRIBUTES","scratchVector","FORMAT_LOADER_MAP","jpeg","png","dds","I3S_ATTRIBUTE_TYPE","parseI3STileContent","arrayBuffer","tile","tileset","options","context","content","featureIds","featureData","constructFeatureDataStruct","attributes","textureUrl","url","i3s","token","loader","textureFormat","response","fetch","image","type","texture","compressed","mipmaps","width","height","data","material","makePbrMaterial","materialDefinition","parseI3SNodeGeometry","vertexCount","byteOffset","featureCount","isDracoGeometry","decompressedGeometry","draco","attributeNameEntry","header","indices","value","POSITION","NORMAL","COLOR_0","TEXCOORD_0","featureIndex","uvRegion","position","normal","color","uv0","id","updateAttributesMetadata","getFeatureIdsFromFeatureIndexMetadata","flattenFeatureIdsByFeatureIndices","vertexAttributes","attributesOrder","featureAttributes","featureAttributeOrder","headers","parseHeaders","normalizedVertexAttributes","offset","normalizeAttributes","normalizedFeatureAttributes","flattenFeatureIdsByFaceRanges","concatAttributes","enuMatrix","cartographicOrigin","cartesianOrigin","parsePositions","matrix","multiplyRight","positions","normals","colors","normalizeAttribute","texCoords","uvRegions","attributeIndex","cartographicCenter","modelMatrix","invert","byteLength","key","loaderData","dracoAttribute","name","metadata","attribute","normalized","defaultGeometrySchema","store","geometryAttribute","namedAttribute","count","valueType","valuesPerElement","ordering","buffer","property","TypedArrayTypeHeader","slice","parseUint64Values","TypedArrayType","size","elementsCount","attributeSize","values","dataView","DataView","index","left","getUint32","right","push","mbs","WGS84","cartographicToCartesian","eastNorthUpToFixedFrame","offsetsToCartesians","fixedFrameToENUMatrix","vertices","Float64Array","length","scaleX","double","scaleY","i","x","y","z","subarray","pbrMaterial","pbrMetallicRoughness","baseColorFactor","baseColorTexture","texCoord","alphaCutoff","alphaMode","toUpperCase","emissiveFactor","convertColorFormat","setMaterialTexture","colorFactor","normalizedColor","source","emissiveTexture","metallicRoughnessTexture","normalTexture","occlusionTexture","faceRange","range","featureIdsLength","orderedFeatureIndices","Uint32Array","startIndex","fillId","Number","endValue","prevValue","trianglesCount","endIndex","fill","featureIndices","result","Float32Array","intArray"],"mappings":"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","sourcesContent":["import type {TypedArray} from '@loaders.gl/schema';\nimport {load, parse} from '@loaders.gl/core';\nimport {Vector3, Matrix4} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\n\nimport type {LoaderOptions, LoaderContext} from '@loaders.gl/loader-utils';\nimport {ImageLoader} from '@loaders.gl/images';\nimport {DracoLoader} from '@loaders.gl/draco';\nimport {CompressedTextureLoader} from '@loaders.gl/textures';\n\nimport {Tileset, Tile} from '../../types';\nimport {getUrlWithToken} from '../utils/url-utils';\n\nimport {\n  GL_TYPE_MAP,\n  TYPE_ARRAY_MAP,\n  SIZEOF,\n  I3S_NAMED_HEADER_ATTRIBUTES,\n  I3S_NAMED_VERTEX_ATTRIBUTES,\n  I3S_NAMED_GEOMETRY_ATTRIBUTES\n} from './constants';\n\nconst scratchVector = new Vector3([0, 0, 0]);\n\nconst FORMAT_LOADER_MAP = {\n  jpeg: ImageLoader,\n  png: ImageLoader,\n  'ktx-etc2': CompressedTextureLoader,\n  dds: CompressedTextureLoader\n};\n\nconst I3S_ATTRIBUTE_TYPE = 'i3s-attribute-type';\n\nexport async function parseI3STileContent(\n  arrayBuffer: ArrayBuffer,\n  tile: Tile,\n  tileset: Tileset,\n  options?: LoaderOptions,\n  context?: LoaderContext\n) {\n  tile.content = tile.content || {};\n  tile.content.featureIds = tile.content.featureIds || null;\n\n  // construct featureData from defaultGeometrySchema;\n  tile.content.featureData = constructFeatureDataStruct(tile, tileset);\n  tile.content.attributes = {};\n\n  if (tile.textureUrl) {\n    const url = getUrlWithToken(tile.textureUrl, options?.i3s?.token);\n    const loader = FORMAT_LOADER_MAP[tile.textureFormat] || ImageLoader;\n    // @ts-ignore context must be defined\n    const response = await fetch(url);\n    const arrayBuffer = await response.arrayBuffer();\n\n    if (loader === ImageLoader) {\n      const options = {image: {type: 'data'}};\n      // @ts-ignore context must be defined\n      // Image constructor is not supported in worker thread.\n      // Do parsing image data on the main thread by using context to avoid worker issues.\n      tile.content.texture = await context.parse(arrayBuffer, options);\n    } else if (loader === CompressedTextureLoader) {\n      // @ts-ignore context must be defined\n      const texture = await load(arrayBuffer, CompressedTextureLoader);\n      tile.content.texture = {\n        compressed: true,\n        mipmaps: false,\n        width: texture[0].width,\n        height: texture[0].height,\n        data: texture\n      };\n    }\n  }\n\n  tile.content.material = makePbrMaterial(tile.materialDefinition, tile.content.texture);\n  if (tile.content.material) {\n    tile.content.texture = null;\n  }\n\n  return await parseI3SNodeGeometry(arrayBuffer, tile, context);\n}\n\n/* eslint-disable max-statements */\nasync function parseI3SNodeGeometry(\n  arrayBuffer: ArrayBuffer,\n  tile: Tile = {},\n  context?: LoaderContext\n) {\n  if (!tile.content) {\n    return tile;\n  }\n\n  const content = tile.content;\n  let attributes;\n  let vertexCount;\n  let byteOffset = 0;\n  let featureCount = 0;\n\n  if (tile.isDracoGeometry) {\n    const decompressedGeometry = await parse(arrayBuffer, DracoLoader, {\n      draco: {\n        attributeNameEntry: I3S_ATTRIBUTE_TYPE\n      }\n    });\n\n    vertexCount = decompressedGeometry.header.vertexCount;\n    const indices = decompressedGeometry.indices.value;\n    const {\n      POSITION,\n      NORMAL,\n      COLOR_0,\n      TEXCOORD_0,\n      ['feature-index']: featureIndex,\n      ['uv-region']: uvRegion\n    } = decompressedGeometry.attributes;\n\n    attributes = {\n      position: POSITION,\n      normal: NORMAL,\n      color: COLOR_0,\n      uv0: TEXCOORD_0,\n      uvRegion,\n      id: featureIndex,\n      indices\n    };\n\n    updateAttributesMetadata(attributes, decompressedGeometry);\n\n    const featureIds = getFeatureIdsFromFeatureIndexMetadata(featureIndex);\n\n    if (featureIds) {\n      flattenFeatureIdsByFeatureIndices(attributes, featureIds);\n    }\n  } else {\n    const {vertexAttributes, attributesOrder, featureAttributes, featureAttributeOrder} =\n      content.featureData;\n    // First 8 bytes reserved for header (vertexCount and featureCount)\n    const headers = parseHeaders(content, arrayBuffer);\n    byteOffset = headers.byteOffset;\n    vertexCount = headers.vertexCount;\n    featureCount = headers.featureCount;\n    // Getting vertex attributes such as positions, normals, colors, etc...\n    const {attributes: normalizedVertexAttributes, byteOffset: offset} = normalizeAttributes(\n      arrayBuffer,\n      byteOffset,\n      vertexAttributes,\n      vertexCount,\n      attributesOrder\n    );\n\n    // Getting feature attributes such as featureIds and faceRange\n    const {attributes: normalizedFeatureAttributes} = normalizeAttributes(\n      arrayBuffer,\n      offset,\n      featureAttributes,\n      featureCount,\n      featureAttributeOrder\n    );\n\n    flattenFeatureIdsByFaceRanges(normalizedFeatureAttributes);\n    attributes = concatAttributes(normalizedVertexAttributes, normalizedFeatureAttributes);\n  }\n\n  const {enuMatrix, cartographicOrigin, cartesianOrigin} = parsePositions(\n    attributes.position,\n    tile\n  );\n\n  const matrix = new Matrix4().multiplyRight(enuMatrix);\n\n  content.attributes = {\n    positions: attributes.position,\n    normals: attributes.normal,\n    colors: normalizeAttribute(attributes.color), // Normalize from UInt8\n    texCoords: attributes.uv0,\n    uvRegions: normalizeAttribute(attributes.uvRegion) // Normalize from UInt16\n  };\n  content.indices = attributes.indices || null;\n\n  if (attributes.id && attributes.id.value) {\n    tile.content.featureIds = attributes.id.value;\n  }\n\n  // Remove undefined attributes\n  for (const attributeIndex in content.attributes) {\n    if (!content.attributes[attributeIndex]) {\n      delete content.attributes[attributeIndex];\n    }\n  }\n\n  content.vertexCount = vertexCount;\n  content.cartographicCenter = cartographicOrigin;\n  content.cartesianOrigin = cartesianOrigin;\n  content.modelMatrix = matrix.invert();\n  content.byteLength = arrayBuffer.byteLength;\n\n  return tile;\n}\n\n/**\n * Update attributes with metadata from decompressed geometry.\n * @param decompressedGeometry\n * @param attributes\n */\nfunction updateAttributesMetadata(attributes, decompressedGeometry) {\n  for (const key in decompressedGeometry.loaderData.attributes) {\n    const dracoAttribute = decompressedGeometry.loaderData.attributes[key];\n\n    switch (dracoAttribute.name) {\n      case 'POSITION':\n        attributes.position.metadata = dracoAttribute.metadata;\n        break;\n      case 'feature-index':\n        attributes.id.metadata = dracoAttribute.metadata;\n        break;\n      default:\n        break;\n    }\n  }\n}\n\n/**\n * Do concatenation of attribute objects.\n * Done as separate fucntion to avoid ts errors.\n * @param {Object} normalizedVertexAttributes\n * @param {Object} normalizedFeatureAttributes\n * @returns {object} - result of attributes concatenation.\n */\nfunction concatAttributes(normalizedVertexAttributes, normalizedFeatureAttributes) {\n  return {...normalizedVertexAttributes, ...normalizedFeatureAttributes};\n}\n\n/**\n * Normalize attribute to range [0..1] . Eg. convert colors buffer from [255,255,255,255] to [1,1,1,1]\n * @param {Object} attribute - geometry attribute\n * @returns {Object} - geometry attribute in right format\n */\nfunction normalizeAttribute(attribute) {\n  if (!attribute) {\n    return attribute;\n  }\n  attribute.normalized = true;\n  return attribute;\n}\n\nfunction constructFeatureDataStruct(tile, tileset) {\n  // seed featureData from defaultGeometrySchema\n  const defaultGeometrySchema = tileset.store.defaultGeometrySchema;\n  const featureData = defaultGeometrySchema;\n  // populate the vertex attributes value types and values per element\n  for (const geometryAttribute in I3S_NAMED_GEOMETRY_ATTRIBUTES) {\n    for (const namedAttribute in I3S_NAMED_VERTEX_ATTRIBUTES) {\n      const attribute = defaultGeometrySchema[geometryAttribute][namedAttribute];\n      if (attribute) {\n        const {byteOffset = 0, count = 0, valueType, valuesPerElement} = attribute;\n\n        featureData[geometryAttribute][namedAttribute] = {\n          valueType,\n          valuesPerElement,\n          byteOffset,\n          count\n        };\n      }\n    }\n  }\n\n  featureData.attributesOrder = defaultGeometrySchema.ordering;\n  return featureData;\n}\n\nfunction parseHeaders(content, buffer) {\n  let byteOffset = 0;\n  // First 8 bytes reserved for header (vertexCount and featurecount)\n  let vertexCount = 0;\n  let featureCount = 0;\n  const headers = content.featureData[I3S_NAMED_HEADER_ATTRIBUTES.header];\n  for (const header in headers) {\n    const {property, type} = headers[header];\n    const TypedArrayTypeHeader = TYPE_ARRAY_MAP[type];\n    if (property === I3S_NAMED_HEADER_ATTRIBUTES.vertexCount) {\n      vertexCount = new TypedArrayTypeHeader(buffer, 0, 4)[0];\n      byteOffset += SIZEOF[type];\n    }\n    if (property === I3S_NAMED_HEADER_ATTRIBUTES.featureCount) {\n      featureCount = new TypedArrayTypeHeader(buffer, 4, 4)[0];\n      byteOffset += SIZEOF[type];\n    }\n  }\n  return {\n    vertexCount,\n    featureCount,\n    byteOffset\n  };\n}\n\n/* eslint-enable max-statements */\n\nfunction normalizeAttributes(\n  arrayBuffer,\n  byteOffset,\n  vertexAttributes,\n  vertexCount,\n  attributesOrder\n) {\n  const attributes = {};\n\n  // the order of attributes depend on the order being added to the vertexAttributes object\n  for (const attribute of attributesOrder) {\n    if (vertexAttributes[attribute]) {\n      const {valueType, valuesPerElement} = vertexAttributes[attribute];\n      // update count and byteOffset count by calculating from defaultGeometrySchema + binnary content\n      const count = vertexCount;\n      // protect from arrayBuffer read overunns by NOT assuming node has regions always even though its declared in defaultGeometrySchema.\n      // In i3s 1.6: client is required to decide that based on ./shared resource of the node (materialDefinitions.[Mat_id].params.vertexRegions == true)\n      // In i3s 1.7 the property has been rolled into the 3d scene layer json/node pages.\n      // Code below does not account when the bytelength is actually bigger than\n      // the calculated value (b\\c the tile potentially could have mesh segmentation information).\n      // In those cases tiles without regions could fail or have garbage values.\n      if (byteOffset + count * valuesPerElement > arrayBuffer.byteLength) {\n        break;\n      }\n      const buffer = arrayBuffer.slice(byteOffset);\n      let value: number[] | TypedArray = [];\n\n      if (valueType === 'UInt64') {\n        value = parseUint64Values(buffer, count * valuesPerElement, SIZEOF[valueType]);\n      } else {\n        const TypedArrayType = TYPE_ARRAY_MAP[valueType];\n        value = new TypedArrayType(buffer, 0, count * valuesPerElement);\n      }\n\n      attributes[attribute] = {\n        value,\n        type: GL_TYPE_MAP[valueType],\n        size: valuesPerElement\n      };\n\n      switch (attribute) {\n        case 'color':\n          // @ts-ignore\n          attributes.color.normalized = true;\n          break;\n        case 'position':\n        case 'region':\n        case 'normal':\n        default:\n      }\n\n      byteOffset = byteOffset + count * valuesPerElement * SIZEOF[valueType];\n    }\n  }\n\n  return {attributes, byteOffset};\n}\n\n/**\n * Parse buffer to return array of uint64 values\n *\n * @param buffer\n * @param elementsCount\n * @returns 64-bit array of values until precision is lost after Number.MAX_SAFE_INTEGER\n */\nfunction parseUint64Values(\n  buffer: ArrayBuffer,\n  elementsCount: number,\n  attributeSize: number\n): number[] {\n  const values: number[] = [];\n  const dataView = new DataView(buffer);\n  let offset = 0;\n\n  for (let index = 0; index < elementsCount; index++) {\n    // split 64-bit number into two 32-bit parts\n    const left = dataView.getUint32(offset, true);\n    const right = dataView.getUint32(offset + 4, true);\n    // combine the two 32-bit values\n    const value = left + 2 ** 32 * right;\n\n    values.push(value);\n    offset += attributeSize;\n  }\n\n  return values;\n}\n\nfunction parsePositions(attribute, tile) {\n  const mbs = tile.mbs;\n  const value = attribute.value;\n  const metadata = attribute.metadata;\n  const enuMatrix = new Matrix4();\n  const cartographicOrigin = new Vector3(mbs[0], mbs[1], mbs[2]);\n  const cartesianOrigin = new Vector3();\n  Ellipsoid.WGS84.cartographicToCartesian(cartographicOrigin, cartesianOrigin);\n  Ellipsoid.WGS84.eastNorthUpToFixedFrame(cartesianOrigin, enuMatrix);\n  attribute.value = offsetsToCartesians(value, metadata, cartographicOrigin);\n\n  return {\n    enuMatrix,\n    fixedFrameToENUMatrix: enuMatrix.invert(),\n    cartographicOrigin,\n    cartesianOrigin\n  };\n}\n\n/**\n * Converts position coordinates to absolute cartesian coordinates\n * @param {Float32Array} vertices - \"position\" attribute data\n * @param {Object} metadata - When the geometry is DRACO compressed, contain position attribute's metadata\n *  https://github.com/Esri/i3s-spec/blob/master/docs/1.7/compressedAttributes.cmn.md\n * @param {Vector3} cartographicOrigin - Cartographic origin coordinates\n * @returns {Float64Array} - converted \"position\" data\n */\nfunction offsetsToCartesians(vertices, metadata = {}, cartographicOrigin) {\n  const positions = new Float64Array(vertices.length);\n  const scaleX = (metadata['i3s-scale_x'] && metadata['i3s-scale_x'].double) || 1;\n  const scaleY = (metadata['i3s-scale_y'] && metadata['i3s-scale_y'].double) || 1;\n  for (let i = 0; i < positions.length; i += 3) {\n    positions[i] = vertices[i] * scaleX + cartographicOrigin.x;\n    positions[i + 1] = vertices[i + 1] * scaleY + cartographicOrigin.y;\n    positions[i + 2] = vertices[i + 2] + cartographicOrigin.z;\n  }\n\n  for (let i = 0; i < positions.length; i += 3) {\n    // @ts-ignore\n    Ellipsoid.WGS84.cartographicToCartesian(positions.subarray(i, i + 3), scratchVector);\n    positions[i] = scratchVector.x;\n    positions[i + 1] = scratchVector.y;\n    positions[i + 2] = scratchVector.z;\n  }\n\n  return positions;\n}\n\n/**\n * Makes a glTF-compatible PBR material from an I3S material definition\n * @param {object} materialDefinition - i3s material definition\n *  https://github.com/Esri/i3s-spec/blob/master/docs/1.7/materialDefinitions.cmn.md\n * @param {object} texture - texture image\n * @returns {object}\n */\nfunction makePbrMaterial(materialDefinition, texture) {\n  let pbrMaterial;\n  if (materialDefinition) {\n    pbrMaterial = {\n      ...materialDefinition,\n      pbrMetallicRoughness: materialDefinition.pbrMetallicRoughness\n        ? {...materialDefinition.pbrMetallicRoughness}\n        : {baseColorFactor: [255, 255, 255, 255]}\n    };\n  } else {\n    pbrMaterial = {\n      pbrMetallicRoughness: {}\n    };\n    if (texture) {\n      pbrMaterial.pbrMetallicRoughness.baseColorTexture = {texCoord: 0};\n    } else {\n      pbrMaterial.pbrMetallicRoughness.baseColorFactor = [255, 255, 255, 255];\n    }\n  }\n\n  // Set default 0.25 per spec https://github.com/Esri/i3s-spec/blob/master/docs/1.7/materialDefinitions.cmn.md\n  pbrMaterial.alphaCutoff = pbrMaterial.alphaCutoff || 0.25;\n\n  if (pbrMaterial.alphaMode) {\n    // I3S contain alphaMode in lowerCase\n    pbrMaterial.alphaMode = pbrMaterial.alphaMode.toUpperCase();\n  }\n\n  // Convert colors from [255,255,255,255] to [1,1,1,1]\n  if (pbrMaterial.emissiveFactor) {\n    pbrMaterial.emissiveFactor = convertColorFormat(pbrMaterial.emissiveFactor);\n  }\n  if (pbrMaterial.pbrMetallicRoughness && pbrMaterial.pbrMetallicRoughness.baseColorFactor) {\n    pbrMaterial.pbrMetallicRoughness.baseColorFactor = convertColorFormat(\n      pbrMaterial.pbrMetallicRoughness.baseColorFactor\n    );\n  }\n\n  setMaterialTexture(pbrMaterial, texture);\n\n  return pbrMaterial;\n}\n\n/**\n * Convert color from [255,255,255,255] to [1,1,1,1]\n * @param {Array} colorFactor - color array\n * @returns {Array} - new color array\n */\nfunction convertColorFormat(colorFactor) {\n  const normalizedColor = [...colorFactor];\n  for (let index = 0; index < colorFactor.length; index++) {\n    normalizedColor[index] = colorFactor[index] / 255;\n  }\n  return normalizedColor;\n}\n\n/**\n * Set texture in PBR material\n * @param {object} material - i3s material definition\n * @param {object} image - texture image\n * @returns {void}\n */\nfunction setMaterialTexture(material, image) {\n  const texture = {source: {image}};\n  // I3SLoader now support loading only one texture. This elseif sequence will assign this texture to one of\n  // properties defined in materialDefinition\n  if (material.pbrMetallicRoughness && material.pbrMetallicRoughness.baseColorTexture) {\n    material.pbrMetallicRoughness.baseColorTexture = {\n      ...material.pbrMetallicRoughness.baseColorTexture,\n      texture\n    };\n  } else if (material.emissiveTexture) {\n    material.emissiveTexture = {...material.emissiveTexture, texture};\n  } else if (\n    material.pbrMetallicRoughness &&\n    material.pbrMetallicRoughness.metallicRoughnessTexture\n  ) {\n    material.pbrMetallicRoughness.metallicRoughnessTexture = {\n      ...material.pbrMetallicRoughness.metallicRoughnessTexture,\n      texture\n    };\n  } else if (material.normalTexture) {\n    material.normalTexture = {...material.normalTexture, texture};\n  } else if (material.occlusionTexture) {\n    material.occlusionTexture = {...material.occlusionTexture, texture};\n  }\n}\n\n/**\n * Flatten feature ids using face ranges\n * @param {object} normalizedFeatureAttributes\n * @returns {void}\n */\nfunction flattenFeatureIdsByFaceRanges(normalizedFeatureAttributes) {\n  const {id, faceRange} = normalizedFeatureAttributes;\n\n  if (!id || !faceRange) {\n    return;\n  }\n\n  const featureIds = id.value;\n  const range = faceRange.value;\n  const featureIdsLength = range[range.length - 1] + 1;\n  const orderedFeatureIndices = new Uint32Array(featureIdsLength * 3);\n\n  let featureIndex = 0;\n  let startIndex = 0;\n\n  for (let index = 1; index < range.length; index += 2) {\n    const fillId = Number(featureIds[featureIndex]);\n    const endValue = range[index];\n    const prevValue = range[index - 1];\n    const trianglesCount = endValue - prevValue + 1;\n    const endIndex = startIndex + trianglesCount * 3;\n\n    orderedFeatureIndices.fill(fillId, startIndex, endIndex);\n\n    featureIndex++;\n    startIndex = endIndex;\n  }\n\n  normalizedFeatureAttributes.id.value = orderedFeatureIndices;\n}\n\n/**\n * Flatten feature ids using featureIndices\n * @param {object} attributes\n * @param {any} featureIds\n * @returns {void}\n */\nfunction flattenFeatureIdsByFeatureIndices(attributes, featureIds) {\n  const featureIndices = attributes.id.value;\n  const result = new Float32Array(featureIndices.length);\n\n  for (let index = 0; index < featureIndices.length; index++) {\n    result[index] = featureIds[featureIndices[index]];\n  }\n\n  attributes.id.value = result;\n}\n\n/**\n * Flatten feature ids using featureIndices\n * @param {object} featureIndex\n * @returns {Int32Array}\n */\nfunction getFeatureIdsFromFeatureIndexMetadata(featureIndex) {\n  return (\n    featureIndex &&\n    featureIndex.metadata &&\n    featureIndex.metadata['i3s-feature-ids'] &&\n    featureIndex.metadata['i3s-feature-ids'].intArray\n  );\n}\n"],"file":"parse-i3s-tile-content.js"}