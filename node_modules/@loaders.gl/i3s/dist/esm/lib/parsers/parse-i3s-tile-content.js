import { load, parse } from '@loaders.gl/core';
import { Vector3, Matrix4 } from '@math.gl/core';
import { Ellipsoid } from '@math.gl/geospatial';
import { ImageLoader } from '@loaders.gl/images';
import { DracoLoader } from '@loaders.gl/draco';
import { CompressedTextureLoader } from '@loaders.gl/textures';
import { getUrlWithToken } from '../utils/url-utils';
import { GL_TYPE_MAP, TYPE_ARRAY_MAP, SIZEOF, I3S_NAMED_HEADER_ATTRIBUTES, I3S_NAMED_VERTEX_ATTRIBUTES, I3S_NAMED_GEOMETRY_ATTRIBUTES } from './constants';
const scratchVector = new Vector3([0, 0, 0]);
const FORMAT_LOADER_MAP = {
  jpeg: ImageLoader,
  png: ImageLoader,
  'ktx-etc2': CompressedTextureLoader,
  dds: CompressedTextureLoader
};
const I3S_ATTRIBUTE_TYPE = 'i3s-attribute-type';
export async function parseI3STileContent(arrayBuffer, tile, tileset, options, context) {
  tile.content = tile.content || {};
  tile.content.featureIds = tile.content.featureIds || null;
  tile.content.featureData = constructFeatureDataStruct(tile, tileset);
  tile.content.attributes = {};

  if (tile.textureUrl) {
    var _options$i3s;

    const url = getUrlWithToken(tile.textureUrl, options === null || options === void 0 ? void 0 : (_options$i3s = options.i3s) === null || _options$i3s === void 0 ? void 0 : _options$i3s.token);
    const loader = FORMAT_LOADER_MAP[tile.textureFormat] || ImageLoader;
    const response = await fetch(url);
    const arrayBuffer = await response.arrayBuffer();

    if (loader === ImageLoader) {
      const options = {
        image: {
          type: 'data'
        }
      };
      tile.content.texture = await context.parse(arrayBuffer, options);
    } else if (loader === CompressedTextureLoader) {
      const texture = await load(arrayBuffer, CompressedTextureLoader);
      tile.content.texture = {
        compressed: true,
        mipmaps: false,
        width: texture[0].width,
        height: texture[0].height,
        data: texture
      };
    }
  }

  tile.content.material = makePbrMaterial(tile.materialDefinition, tile.content.texture);

  if (tile.content.material) {
    tile.content.texture = null;
  }

  return await parseI3SNodeGeometry(arrayBuffer, tile, context);
}

async function parseI3SNodeGeometry(arrayBuffer, tile = {}, context) {
  if (!tile.content) {
    return tile;
  }

  const content = tile.content;
  let attributes;
  let vertexCount;
  let byteOffset = 0;
  let featureCount = 0;

  if (tile.isDracoGeometry) {
    const decompressedGeometry = await parse(arrayBuffer, DracoLoader, {
      draco: {
        attributeNameEntry: I3S_ATTRIBUTE_TYPE
      }
    });
    vertexCount = decompressedGeometry.header.vertexCount;
    const indices = decompressedGeometry.indices.value;
    const {
      POSITION,
      NORMAL,
      COLOR_0,
      TEXCOORD_0,
      ['feature-index']: featureIndex,
      ['uv-region']: uvRegion
    } = decompressedGeometry.attributes;
    attributes = {
      position: POSITION,
      normal: NORMAL,
      color: COLOR_0,
      uv0: TEXCOORD_0,
      uvRegion,
      id: featureIndex,
      indices
    };
    updateAttributesMetadata(attributes, decompressedGeometry);
    const featureIds = getFeatureIdsFromFeatureIndexMetadata(featureIndex);

    if (featureIds) {
      flattenFeatureIdsByFeatureIndices(attributes, featureIds);
    }
  } else {
    const {
      vertexAttributes,
      attributesOrder,
      featureAttributes,
      featureAttributeOrder
    } = content.featureData;
    const headers = parseHeaders(content, arrayBuffer);
    byteOffset = headers.byteOffset;
    vertexCount = headers.vertexCount;
    featureCount = headers.featureCount;
    const {
      attributes: normalizedVertexAttributes,
      byteOffset: offset
    } = normalizeAttributes(arrayBuffer, byteOffset, vertexAttributes, vertexCount, attributesOrder);
    const {
      attributes: normalizedFeatureAttributes
    } = normalizeAttributes(arrayBuffer, offset, featureAttributes, featureCount, featureAttributeOrder);
    flattenFeatureIdsByFaceRanges(normalizedFeatureAttributes);
    attributes = concatAttributes(normalizedVertexAttributes, normalizedFeatureAttributes);
  }

  const {
    enuMatrix,
    cartographicOrigin,
    cartesianOrigin
  } = parsePositions(attributes.position, tile);
  const matrix = new Matrix4().multiplyRight(enuMatrix);
  content.attributes = {
    positions: attributes.position,
    normals: attributes.normal,
    colors: normalizeAttribute(attributes.color),
    texCoords: attributes.uv0,
    uvRegions: normalizeAttribute(attributes.uvRegion)
  };
  content.indices = attributes.indices || null;

  if (attributes.id && attributes.id.value) {
    tile.content.featureIds = attributes.id.value;
  }

  for (const attributeIndex in content.attributes) {
    if (!content.attributes[attributeIndex]) {
      delete content.attributes[attributeIndex];
    }
  }

  content.vertexCount = vertexCount;
  content.cartographicCenter = cartographicOrigin;
  content.cartesianOrigin = cartesianOrigin;
  content.modelMatrix = matrix.invert();
  content.byteLength = arrayBuffer.byteLength;
  return tile;
}

function updateAttributesMetadata(attributes, decompressedGeometry) {
  for (const key in decompressedGeometry.loaderData.attributes) {
    const dracoAttribute = decompressedGeometry.loaderData.attributes[key];

    switch (dracoAttribute.name) {
      case 'POSITION':
        attributes.position.metadata = dracoAttribute.metadata;
        break;

      case 'feature-index':
        attributes.id.metadata = dracoAttribute.metadata;
        break;

      default:
        break;
    }
  }
}

function concatAttributes(normalizedVertexAttributes, normalizedFeatureAttributes) {
  return { ...normalizedVertexAttributes,
    ...normalizedFeatureAttributes
  };
}

function normalizeAttribute(attribute) {
  if (!attribute) {
    return attribute;
  }

  attribute.normalized = true;
  return attribute;
}

function constructFeatureDataStruct(tile, tileset) {
  const defaultGeometrySchema = tileset.store.defaultGeometrySchema;
  const featureData = defaultGeometrySchema;

  for (const geometryAttribute in I3S_NAMED_GEOMETRY_ATTRIBUTES) {
    for (const namedAttribute in I3S_NAMED_VERTEX_ATTRIBUTES) {
      const attribute = defaultGeometrySchema[geometryAttribute][namedAttribute];

      if (attribute) {
        const {
          byteOffset = 0,
          count = 0,
          valueType,
          valuesPerElement
        } = attribute;
        featureData[geometryAttribute][namedAttribute] = {
          valueType,
          valuesPerElement,
          byteOffset,
          count
        };
      }
    }
  }

  featureData.attributesOrder = defaultGeometrySchema.ordering;
  return featureData;
}

function parseHeaders(content, buffer) {
  let byteOffset = 0;
  let vertexCount = 0;
  let featureCount = 0;
  const headers = content.featureData[I3S_NAMED_HEADER_ATTRIBUTES.header];

  for (const header in headers) {
    const {
      property,
      type
    } = headers[header];
    const TypedArrayTypeHeader = TYPE_ARRAY_MAP[type];

    if (property === I3S_NAMED_HEADER_ATTRIBUTES.vertexCount) {
      vertexCount = new TypedArrayTypeHeader(buffer, 0, 4)[0];
      byteOffset += SIZEOF[type];
    }

    if (property === I3S_NAMED_HEADER_ATTRIBUTES.featureCount) {
      featureCount = new TypedArrayTypeHeader(buffer, 4, 4)[0];
      byteOffset += SIZEOF[type];
    }
  }

  return {
    vertexCount,
    featureCount,
    byteOffset
  };
}

function normalizeAttributes(arrayBuffer, byteOffset, vertexAttributes, vertexCount, attributesOrder) {
  const attributes = {};

  for (const attribute of attributesOrder) {
    if (vertexAttributes[attribute]) {
      const {
        valueType,
        valuesPerElement
      } = vertexAttributes[attribute];
      const count = vertexCount;

      if (byteOffset + count * valuesPerElement > arrayBuffer.byteLength) {
        break;
      }

      const buffer = arrayBuffer.slice(byteOffset);
      let value = [];

      if (valueType === 'UInt64') {
        value = parseUint64Values(buffer, count * valuesPerElement, SIZEOF[valueType]);
      } else {
        const TypedArrayType = TYPE_ARRAY_MAP[valueType];
        value = new TypedArrayType(buffer, 0, count * valuesPerElement);
      }

      attributes[attribute] = {
        value,
        type: GL_TYPE_MAP[valueType],
        size: valuesPerElement
      };

      switch (attribute) {
        case 'color':
          attributes.color.normalized = true;
          break;

        case 'position':
        case 'region':
        case 'normal':
        default:
      }

      byteOffset = byteOffset + count * valuesPerElement * SIZEOF[valueType];
    }
  }

  return {
    attributes,
    byteOffset
  };
}

function parseUint64Values(buffer, elementsCount, attributeSize) {
  const values = [];
  const dataView = new DataView(buffer);
  let offset = 0;

  for (let index = 0; index < elementsCount; index++) {
    const left = dataView.getUint32(offset, true);
    const right = dataView.getUint32(offset + 4, true);
    const value = left + 2 ** 32 * right;
    values.push(value);
    offset += attributeSize;
  }

  return values;
}

function parsePositions(attribute, tile) {
  const mbs = tile.mbs;
  const value = attribute.value;
  const metadata = attribute.metadata;
  const enuMatrix = new Matrix4();
  const cartographicOrigin = new Vector3(mbs[0], mbs[1], mbs[2]);
  const cartesianOrigin = new Vector3();
  Ellipsoid.WGS84.cartographicToCartesian(cartographicOrigin, cartesianOrigin);
  Ellipsoid.WGS84.eastNorthUpToFixedFrame(cartesianOrigin, enuMatrix);
  attribute.value = offsetsToCartesians(value, metadata, cartographicOrigin);
  return {
    enuMatrix,
    fixedFrameToENUMatrix: enuMatrix.invert(),
    cartographicOrigin,
    cartesianOrigin
  };
}

function offsetsToCartesians(vertices, metadata = {}, cartographicOrigin) {
  const positions = new Float64Array(vertices.length);
  const scaleX = metadata['i3s-scale_x'] && metadata['i3s-scale_x'].double || 1;
  const scaleY = metadata['i3s-scale_y'] && metadata['i3s-scale_y'].double || 1;

  for (let i = 0; i < positions.length; i += 3) {
    positions[i] = vertices[i] * scaleX + cartographicOrigin.x;
    positions[i + 1] = vertices[i + 1] * scaleY + cartographicOrigin.y;
    positions[i + 2] = vertices[i + 2] + cartographicOrigin.z;
  }

  for (let i = 0; i < positions.length; i += 3) {
    Ellipsoid.WGS84.cartographicToCartesian(positions.subarray(i, i + 3), scratchVector);
    positions[i] = scratchVector.x;
    positions[i + 1] = scratchVector.y;
    positions[i + 2] = scratchVector.z;
  }

  return positions;
}

function makePbrMaterial(materialDefinition, texture) {
  let pbrMaterial;

  if (materialDefinition) {
    pbrMaterial = { ...materialDefinition,
      pbrMetallicRoughness: materialDefinition.pbrMetallicRoughness ? { ...materialDefinition.pbrMetallicRoughness
      } : {
        baseColorFactor: [255, 255, 255, 255]
      }
    };
  } else {
    pbrMaterial = {
      pbrMetallicRoughness: {}
    };

    if (texture) {
      pbrMaterial.pbrMetallicRoughness.baseColorTexture = {
        texCoord: 0
      };
    } else {
      pbrMaterial.pbrMetallicRoughness.baseColorFactor = [255, 255, 255, 255];
    }
  }

  pbrMaterial.alphaCutoff = pbrMaterial.alphaCutoff || 0.25;

  if (pbrMaterial.alphaMode) {
    pbrMaterial.alphaMode = pbrMaterial.alphaMode.toUpperCase();
  }

  if (pbrMaterial.emissiveFactor) {
    pbrMaterial.emissiveFactor = convertColorFormat(pbrMaterial.emissiveFactor);
  }

  if (pbrMaterial.pbrMetallicRoughness && pbrMaterial.pbrMetallicRoughness.baseColorFactor) {
    pbrMaterial.pbrMetallicRoughness.baseColorFactor = convertColorFormat(pbrMaterial.pbrMetallicRoughness.baseColorFactor);
  }

  setMaterialTexture(pbrMaterial, texture);
  return pbrMaterial;
}

function convertColorFormat(colorFactor) {
  const normalizedColor = [...colorFactor];

  for (let index = 0; index < colorFactor.length; index++) {
    normalizedColor[index] = colorFactor[index] / 255;
  }

  return normalizedColor;
}

function setMaterialTexture(material, image) {
  const texture = {
    source: {
      image
    }
  };

  if (material.pbrMetallicRoughness && material.pbrMetallicRoughness.baseColorTexture) {
    material.pbrMetallicRoughness.baseColorTexture = { ...material.pbrMetallicRoughness.baseColorTexture,
      texture
    };
  } else if (material.emissiveTexture) {
    material.emissiveTexture = { ...material.emissiveTexture,
      texture
    };
  } else if (material.pbrMetallicRoughness && material.pbrMetallicRoughness.metallicRoughnessTexture) {
    material.pbrMetallicRoughness.metallicRoughnessTexture = { ...material.pbrMetallicRoughness.metallicRoughnessTexture,
      texture
    };
  } else if (material.normalTexture) {
    material.normalTexture = { ...material.normalTexture,
      texture
    };
  } else if (material.occlusionTexture) {
    material.occlusionTexture = { ...material.occlusionTexture,
      texture
    };
  }
}

function flattenFeatureIdsByFaceRanges(normalizedFeatureAttributes) {
  const {
    id,
    faceRange
  } = normalizedFeatureAttributes;

  if (!id || !faceRange) {
    return;
  }

  const featureIds = id.value;
  const range = faceRange.value;
  const featureIdsLength = range[range.length - 1] + 1;
  const orderedFeatureIndices = new Uint32Array(featureIdsLength * 3);
  let featureIndex = 0;
  let startIndex = 0;

  for (let index = 1; index < range.length; index += 2) {
    const fillId = Number(featureIds[featureIndex]);
    const endValue = range[index];
    const prevValue = range[index - 1];
    const trianglesCount = endValue - prevValue + 1;
    const endIndex = startIndex + trianglesCount * 3;
    orderedFeatureIndices.fill(fillId, startIndex, endIndex);
    featureIndex++;
    startIndex = endIndex;
  }

  normalizedFeatureAttributes.id.value = orderedFeatureIndices;
}

function flattenFeatureIdsByFeatureIndices(attributes, featureIds) {
  const featureIndices = attributes.id.value;
  const result = new Float32Array(featureIndices.length);

  for (let index = 0; index < featureIndices.length; index++) {
    result[index] = featureIds[featureIndices[index]];
  }

  attributes.id.value = result;
}

function getFeatureIdsFromFeatureIndexMetadata(featureIndex) {
  return featureIndex && featureIndex.metadata && featureIndex.metadata['i3s-feature-ids'] && featureIndex.metadata['i3s-feature-ids'].intArray;
}
//# sourceMappingURL=parse-i3s-tile-content.js.map