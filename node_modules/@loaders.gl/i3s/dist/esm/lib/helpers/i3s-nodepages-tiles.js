import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { load } from '@loaders.gl/core';
import { getSupportedGPUTextureFormats } from '@loaders.gl/textures';
import { I3SNodePageLoader } from '../../i3s-node-page-loader';
import { normalizeTileNonUrlData } from '../parsers/parse-i3s';
import { getUrlWithToken, generateTilesetAttributeUrls } from '../utils/url-utils';
export default class I3SNodePagesTiles {
  constructor(tileset, options) {
    _defineProperty(this, "tileset", void 0);

    _defineProperty(this, "nodePages", void 0);

    _defineProperty(this, "nodesPerPage", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "lodSelectionMetricType", void 0);

    _defineProperty(this, "textureDefinitionsSelectedFormats", void 0);

    this.tileset = { ...tileset
    };
    this.nodesPerPage = tileset.nodePages.nodesPerPage;
    this.lodSelectionMetricType = tileset.nodePages.lodSelectionMetricType;
    this.options = options;
    this.nodePages = [];
    this.textureDefinitionsSelectedFormats = [];

    this._initSelectedFormatsForTextureDefinitions(tileset);
  }

  async getNodeById(id) {
    const pageIndex = Math.floor(id / this.nodesPerPage);

    if (!this.nodePages[pageIndex]) {
      var _this$options$i3s;

      const nodePageUrl = getUrlWithToken(`${this.tileset.url}/nodepages/${pageIndex}`, (_this$options$i3s = this.options.i3s) === null || _this$options$i3s === void 0 ? void 0 : _this$options$i3s.token);
      this.nodePages[pageIndex] = load(nodePageUrl, I3SNodePageLoader, this.options);
      this.nodePages[pageIndex] = await this.nodePages[pageIndex];
    }

    if (this.nodePages[pageIndex] instanceof Promise) {
      this.nodePages[pageIndex] = await this.nodePages[pageIndex];
    }

    const nodeIndex = id % this.nodesPerPage;
    return this.nodePages[pageIndex].nodes[nodeIndex];
  }

  async formTileFromNodePages(id) {
    const node = await this.getNodeById(id);
    const children = [];

    for (const child of node.children || []) {
      const childNode = await this.getNodeById(child);
      children.push({
        id: child,
        obb: childNode.obb
      });
    }

    let contentUrl = null;
    let textureUrl = null;
    let materialDefinition = null;
    let textureFormat = 'jpeg';
    let attributeUrls = [];
    let isDracoGeometry = false;

    if (node && node.mesh) {
      const {
        url,
        isDracoGeometry: isDracoGeometryResult
      } = node.mesh.geometry && this._getContentUrl(node.mesh.geometry) || {
        url: null,
        isDracoGeometry: null
      };
      contentUrl = url;
      isDracoGeometry = isDracoGeometryResult;

      const [textureData, nodeMaterialDefinition] = this._getInformationFromMaterial(node.mesh.material);

      materialDefinition = nodeMaterialDefinition;
      textureFormat = textureData.format || textureFormat;

      if (textureData.name) {
        textureUrl = `${this.tileset.url}/nodes/${node.mesh.material.resource}/textures/${textureData.name}`;
      }

      if (this.tileset.attributeStorageInfo) {
        attributeUrls = generateTilesetAttributeUrls(this.tileset, node.mesh.attribute.resource);
      }
    }

    const lodSelection = this._getLodSelection(node);

    return normalizeTileNonUrlData({
      id,
      lodSelection,
      obb: node.obb,
      contentUrl,
      textureUrl,
      attributeUrls,
      materialDefinition,
      textureFormat,
      children,
      isDracoGeometry
    });
  }

  _getContentUrl(meshGeometryData) {
    let result = {};
    const geometryDefinition = this.tileset.geometryDefinitions[meshGeometryData.definition];
    let geometryIndex = -1;

    if (this.options.i3s && this.options.i3s.useDracoGeometry) {
      geometryIndex = geometryDefinition.geometryBuffers.findIndex(buffer => buffer.compressedAttributes && buffer.compressedAttributes.encoding === 'draco');
    }

    if (geometryIndex === -1) {
      geometryIndex = geometryDefinition.geometryBuffers.findIndex(buffer => !buffer.compressedAttributes);
    }

    if (geometryIndex !== -1) {
      const isDracoGeometry = Boolean(geometryDefinition.geometryBuffers[geometryIndex].compressedAttributes);
      result = {
        url: `${this.tileset.url}/nodes/${meshGeometryData.resource}/geometries/${geometryIndex}`,
        isDracoGeometry
      };
    }

    return result;
  }

  _getLodSelection(node) {
    const lodSelection = [];

    if (this.lodSelectionMetricType === 'maxScreenThresholdSQ') {
      lodSelection.push({
        metricType: 'maxScreenThreshold',
        maxError: Math.sqrt(node.lodThreshold / (Math.PI * 0.25))
      });
    }

    lodSelection.push({
      metricType: this.lodSelectionMetricType,
      maxError: node.lodThreshold
    });
    return lodSelection;
  }

  _getInformationFromMaterial(material) {
    const textureDataDefault = {
      name: null,
      format: null
    };

    if (material) {
      const materialDefinition = this.tileset.materialDefinitions[material.definition];
      const textureSetDefinitionIndex = materialDefinition && materialDefinition.pbrMetallicRoughness && materialDefinition.pbrMetallicRoughness.baseColorTexture && materialDefinition.pbrMetallicRoughness.baseColorTexture.textureSetDefinitionId;

      if (textureSetDefinitionIndex || textureSetDefinitionIndex === 0) {
        const textureData = this.textureDefinitionsSelectedFormats[textureSetDefinitionIndex] || textureDataDefault;
        return [textureData, materialDefinition];
      }

      return [textureDataDefault, materialDefinition];
    }

    return [textureDataDefault, null];
  }

  _initSelectedFormatsForTextureDefinitions(tileset) {
    this.textureDefinitionsSelectedFormats = [];

    const possibleI3sFormats = this._getSupportedTextureFormats();

    const textureSetDefinitions = tileset.textureSetDefinitions || [];

    for (const textureSetDefinition of textureSetDefinitions) {
      const formats = textureSetDefinition && textureSetDefinition.formats || [];
      let selectedFormat = null;

      for (const i3sFormat of possibleI3sFormats) {
        const format = formats.find(value => value.format === i3sFormat);

        if (format) {
          selectedFormat = format;
          break;
        }
      }

      this.textureDefinitionsSelectedFormats.push(selectedFormat);
    }
  }

  _getSupportedTextureFormats() {
    const formats = [];

    if (!this.options.i3s || this.options.i3s.useCompressedTextures) {
      const supportedCompressedFormats = getSupportedGPUTextureFormats();

      if (supportedCompressedFormats.has('etc2')) {
        formats.push('ktx-etc2');
      }

      if (supportedCompressedFormats.has('dxt')) {
        formats.push('dds');
      }
    }

    formats.push('jpg');
    formats.push('png');
    return formats;
  }

}
//# sourceMappingURL=i3s-nodepages-tiles.js.map